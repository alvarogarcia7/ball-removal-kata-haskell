head $ dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
head dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
[xs !! i|i<- [1..2]]
[xs !! i |i<- [0..2]]
[xs !! i |i<- [2..2]]
[xs !! i |i<- [1..2]]
let xs = [R,N,R]
let xs = [R,N,R],[xs !! i |i<- [R, N, R]
drop 1 [R, N, R]
drop 0 [R, N, R]
removeOne 0 [R, N, R]
removeOne 0 [L, N, R]
removeOne [L, N, R]
[L, N, R]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 1 [L,L]
:l Spec.hs 
replaceAtIndex 1 R [L,L,L]
:l Spec.hs 
length $ filter (\x->x /= N) [L, L]
length $ filter (\x->x /= N) [L, N]
minBound Directions
minBound Direction
:l Spec.hs 
minBound Direction
minBound Direction
minBound :: Direction
minBound Direction
[minBound..maxBound] :: Direction
[minBound..maxBound] Direction
:t L
L
Direction any
Direction
any Direction
getCandidates [L,L]
length  [L,L]
getCandidates [L,L]
:l Spec.hs 
:t ([L] :: Directions)
[L] :: Directions
Directions
Directions [L]
type Directions = [Direction]
Da 1
data Da = Vector
Da []
Da
data Da = Array Direction 
D
data D = Array Direction 
([L, N] :: D)
[L, N] :: D
data D = Array Direction 
let d = D [L, N, R]
d
let d = [L, N, R]
let D = [L, N, R]
D = [L, N, R]
data D = Array Direction 
data D a = [a]
data D a = [a]
getCandidates [1,2,4,6,3]
getCandidates [1,2,4,3]
getCandidates [1,2,3]
let getCandidates xs = reverse $ drop 1 $ reverse $ drop 1 xs
getCandidates [1,2,3]
getCandidates [1,2,3]
let getCandidates xs = drop (length xs) $ drop 1 [1,2,3] 
drop 1 [1,2,3] 
map parseDirection "><55"
ls
parseDirection '<'
:l Spec.hs 
parseDirection '<'
:l Spec.hs 
:k case of
:t case of
:t in
:t in case
:t case
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) 
data Direction = L|R|N

head $ dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
head dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
[xs !! i|i<- [1..2]]
[xs !! i |i<- [0..2]]
[xs !! i |i<- [2..2]]
[xs !! i |i<- [1..2]]
let xs = [R,N,R]
let xs = [R,N,R],[xs !! i |i<- [R, N, R]
drop 1 [R, N, R]
drop 0 [R, N, R]
removeOne 0 [R, N, R]
removeOne 0 [L, N, R]
removeOne [L, N, R]
[L, N, R]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 1 [L,L]
:l Spec.hs 
replaceAtIndex 1 R [L,L,L]
:l Spec.hs 
length $ filter (\x->x /= N) [L, L]
length $ filter (\x->x /= N) [L, N]
minBound Directions
minBound Direction
:l Spec.hs 
minBound Direction
minBound Direction
minBound :: Direction
minBound Direction
[minBound..maxBound] :: Direction
[minBound..maxBound] Direction
:t L
L
Direction any
Direction
any Direction
getCandidates [L,L]
length  [L,L]
getCandidates [L,L]
:l Spec.hs 
:t ([L] :: Directions)
[L] :: Directions
Directions
Directions [L]
type Directions = [Direction]
Da 1
data Da = Vector
Da []
Da
data Da = Array Direction 
D
data D = Array Direction 
([L, N] :: D)
[L, N] :: D
data D = Array Direction 
let d = D [L, N, R]
d
let d = [L, N, R]
let D = [L, N, R]
D = [L, N, R]
data D = Array Direction 
data D a = [a]
data D a = [a]
getCandidates [1,2,4,6,3]
getCandidates [1,2,4,3]
getCandidates [1,2,3]
let getCandidates xs = reverse $ drop 1 $ reverse $ drop 1 xs
getCandidates [1,2,3]
getCandidates [1,2,3]
let getCandidates xs = drop (length xs) $ drop 1 [1,2,3] 
drop 1 [1,2,3] 
map parseDirection "><55"
ls
parseDirection '<'
:l Spec.hs 
parseDirection '<'
:l Spec.hs 
:k case of
:t case of
:t in
:t in case
:t case
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) 
data Direction = L|R|N

head $ dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
head dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
dropWhile (\x -> x == N) [xs !! i|i<- [1..2]]
[xs !! i|i<- [1..2]]
[xs !! i |i<- [0..2]]
[xs !! i |i<- [2..2]]
[xs !! i |i<- [1..2]]
let xs = [R,N,R]
let xs = [R,N,R],[xs !! i |i<- [R, N, R]
drop 1 [R, N, R]
drop 0 [R, N, R]
removeOne 0 [R, N, R]
removeOne 0 [L, N, R]
removeOne [L, N, R]
[L, N, R]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 1 [L,L]
:l Spec.hs 
replaceAtIndex 1 R [L,L,L]
:l Spec.hs 
length $ filter (\x->x /= N) [L, L]
length $ filter (\x->x /= N) [L, N]
minBound Directions
minBound Direction
:l Spec.hs 
minBound Direction
minBound Direction
minBound :: Direction
minBound Direction
[minBound..maxBound] :: Direction
[minBound..maxBound] Direction
:t L
L
Direction any
Direction
any Direction
getCandidates [L,L]
length  [L,L]
getCandidates [L,L]
:l Spec.hs 
:t ([L] :: Directions)
[L] :: Directions
Directions
Directions [L]
type Directions = [Direction]
Da 1
data Da = Vector
Da []
Da
data Da = Array Direction 
D
data D = Array Direction 
([L, N] :: D)
[L, N] :: D
data D = Array Direction 
let d = D [L, N, R]
d
let d = [L, N, R]
let D = [L, N, R]
D = [L, N, R]
data D = Array Direction 
data D a = [a]
data D a = [a]
getCandidates [1,2,4,6,3]
getCandidates [1,2,4,3]
getCandidates [1,2,3]
let getCandidates xs = reverse $ drop 1 $ reverse $ drop 1 xs
getCandidates [1,2,3]
getCandidates [1,2,3]
let getCandidates xs = drop (length xs) $ drop 1 [1,2,3] 
drop 1 [1,2,3] 
map parseDirection "><55"
ls
parseDirection '<'
:l Spec.hs 
parseDirection '<'
:l Spec.hs 
:k case of
:t case of
:t in
:t in case
:t case
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) 
data Direction = L|R|N

removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 2 [L,R,L]
:l Spec.hs 
removeOne 1 [L,L]
:l Spec.hs 
replaceAtIndex 1 R [L,L,L]
:l Spec.hs 
length $ filter (\x->x /= N) [L, L]
length $ filter (\x->x /= N) [L, N]
minBound Directions
minBound Direction
:l Spec.hs 
minBound Direction
minBound Direction
minBound :: Direction
minBound Direction
[minBound..maxBound] :: Direction
[minBound..maxBound] Direction
:t L
L
Direction any
Direction
any Direction
getCandidates [L,L]
length  [L,L]
getCandidates [L,L]
:l Spec.hs 
:t ([L] :: Directions)
[L] :: Directions
Directions
Directions [L]
type Directions = [Direction]
Da 1
data Da = Vector
Da []
Da
data Da = Array Direction 
D
data D = Array Direction 
([L, N] :: D)
[L, N] :: D
data D = Array Direction 
let d = D [L, N, R]
d
let d = [L, N, R]
let D = [L, N, R]
D = [L, N, R]
data D = Array Direction 
data D a = [a]
data D a = [a]
getCandidates [1,2,4,6,3]
getCandidates [1,2,4,3]
getCandidates [1,2,3]
let getCandidates xs = reverse $ drop 1 $ reverse $ drop 1 xs
getCandidates [1,2,3]
getCandidates [1,2,3]
let getCandidates xs = drop (length xs) $ drop 1 [1,2,3] 
drop 1 [1,2,3] 
map parseDirection "><55"
ls
parseDirection '<'
:l Spec.hs 
parseDirection '<'
:l Spec.hs 
:k case of
:t case of
:t in
:t in case
:t case
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) 
data Direction = L|R|N

removeOne 1 [L,L]
:l Spec.hs 
replaceAtIndex 1 R [L,L,L]
:l Spec.hs 
length $ filter (\x->x /= N) [L, L]
length $ filter (\x->x /= N) [L, N]
minBound Directions
minBound Direction
:l Spec.hs 
minBound Direction
minBound Direction
minBound :: Direction
minBound Direction
[minBound..maxBound] :: Direction
[minBound..maxBound] Direction
:t L
L
Direction any
Direction
any Direction
getCandidates [L,L]
length  [L,L]
getCandidates [L,L]
:l Spec.hs 
:t ([L] :: Directions)
[L] :: Directions
Directions
Directions [L]
type Directions = [Direction]
Da 1
data Da = Vector
Da []
Da
data Da = Array Direction 
D
data D = Array Direction 
([L, N] :: D)
[L, N] :: D
data D = Array Direction 
let d = D [L, N, R]
d
let d = [L, N, R]
let D = [L, N, R]
D = [L, N, R]
data D = Array Direction 
data D a = [a]
data D a = [a]
getCandidates [1,2,4,6,3]
getCandidates [1,2,4,3]
getCandidates [1,2,3]
let getCandidates xs = reverse $ drop 1 $ reverse $ drop 1 xs
getCandidates [1,2,3]
getCandidates [1,2,3]
let getCandidates xs = drop (length xs) $ drop 1 [1,2,3] 
drop 1 [1,2,3] 
map parseDirection "><55"
ls
parseDirection '<'
:l Spec.hs 
parseDirection '<'
:l Spec.hs 
:k case of
:t case of
:t in
:t in case
:t case
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) x
let toDirection x = map (\c -> c in case of '<' L) 
data Direction = L|R|N






filter (not . id) $ map property_sumDigits_ge_sumDigits_factors_n  [2..11000]
filter (not . id) $ map property_sumDigits_ge_sumDigits_factors_n  [2..1100]
filter (not . id) $ map property_sumDigits_ge_sumDigits_factors_n  [2..10]
filter (not . id) $ map property_sumDigits_ge_sumDigits_factors_n  [1..10]
:l Spec.hs 
filter (not . id) $ map property_sumDigits_ge_n [1..1000000]
filter (not . id) $ map property_sumDigits_ge_n [1..100000]
filter (not . id) $ map property_sumDigits_ge_n [1..10000]
filter (not . id) $ map property_sumDigits_ge_n [1..]
filter (!id) $ map property_sumDigits_ge_n [1..]
filter (id) $ map property_sumDigits_ge_n [1..]
filter (not id) $ map property_sumDigits_ge_n [1..]
map property_sumDigits_ge_n [1..]
property_sumDigits_ge_n 1
:l Spec.hs 
:k Num
Main.abs $ Integer' (-1)
Main.abs $ Integer' -1
Main.abs $ Integer' 1
abs $ Integer' 1
:l Spec.hs 
abs $ Integer' 1
abs Integer' 1
Integer' 1
Integer' 1
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
Integer' 1
let property_sumDigits_ge_n (Integer n) = (n - (sumDigits n)) >= 0
let property_sumDigits_ge_n (Integer n) =  (n - (sumDigits n=)) >= 0
let property_sumDigits_ge_n (Integer n) = 0 <= $ n - $ sumDigits n
let property_sumDigits_ge_n (Integer n) = 0 <= n - $ sumDigits n
22 - sumDigits 22
sumDigits 22
:l Spec.hs 
max 1 1
max 1, 1
max(1, 1)
main
quickCheck prop_true 
:l Spec.hs 
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
1 + 1
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) (show 1234)
map (\x -> read x :: Int) (show 1234)
map (\x -> read x :: Int) $ show 1234
:t splitAt 
splitAt "," "abc"
split "," $ intersperse "," $ show 1234
show 1234
"" + 1234
let n = 1234
isSmith 6
isSmith 5
isSmith 4
isSmith 3
isSmith 2
isSmith 1
isSmith 0
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 0
isSmith 26
isSmith 22
isSmith 50
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
null [1]
null []
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 1
isSmith 1
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
foldl1 (+) $ map sumDigits $ factors (37 * 2)
reduce (+) $ map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37*2)
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
1 + 1
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
foldl1 (+) $ map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) $ show 1234
map (\x -> read [x] :: Int) (show 1234)
map (\x -> read x :: Int) (show 1234)
map (\x -> read x :: Int) $ show 1234
:t splitAt 
splitAt "," "abc"
split "," $ intersperse "," $ show 1234
show 1234
"" + 1234
let n = 1234
isSmith 6
isSmith 5
isSmith 4
isSmith 3
isSmith 2
isSmith 1
isSmith 0
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 0
isSmith 26
isSmith 22
isSmith 50
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
null [1]
null []
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
isSmith 1
isSmith 1
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
foldl1 (+) $ map sumDigits $ factors (37 * 2)
reduce (+) $ map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37 * 2)
map sumDigits $ factors (37*2)
map sumDigits $ factors 37*2
map sumDigits $ factors 1584
map sumDigits $ factors 1
foldl1 sumDigits $ factors 1
let isSmith n = sumDigits n == foldl1 sumDigits $ factors n
:l Spec.hs 
factors 1584
:l Spec.hs 
factors 1584
:l Spec.hs 
:l Spec.hs 
factors' 1584 []
factors' 777 []
factors' 734567777 []
factors' 73456 []
factors' 280 []
factors' 80 []
factors' 40 []
factors' 40 [4]
factors' 40 []
:l Spec.hs 
:l Spec.hs 
factors' 40 []
:l Spec.hs 
factors' 40 []
factors' 5 []
factors' 5
:l Spec.hs 
:l Spec.hs 
:l Spec.hs 
foldl1 (*) [2,3]
foldl1 [2,3] (*)
foldl1 [2,3] *
factors 56
factors 5
:l Spec.hs 
:l Spec.hs 
:k Integral 
:t Integral 
Integral
Integral 1
Integral:: 1
Integral 1
